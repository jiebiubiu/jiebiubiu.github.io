<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>笔记记录</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="README.zh.html">介绍</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">笔记</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> mysql</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="mysql/索引.html"><strong aria-hidden="true">1.1.</strong> 索引</a></li><li class="chapter-item expanded "><a href="mysql/性能分析.html"><strong aria-hidden="true">1.2.</strong> 性能分析</a></li><li class="chapter-item expanded "><a href="mysql/datetime&timestamep.html"><strong aria-hidden="true">1.3.</strong> 数据库时间字段</a></li><li class="chapter-item expanded "><a href="mysql/高可用.html"><strong aria-hidden="true">1.4.</strong> 高可用</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> golang</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="golang/包管理.html"><strong aria-hidden="true">2.1.</strong> 包管理</a></li><li class="chapter-item expanded "><a href="golang/构建自己的库.html"><strong aria-hidden="true">2.2.</strong> 构建自己的库</a></li><li class="chapter-item expanded "><a href="golang/基础语法.html"><strong aria-hidden="true">2.3.</strong> 基础语法</a></li><li class="chapter-item expanded "><a href="golang/交叉编译.html"><strong aria-hidden="true">2.4.</strong> 交叉编译</a></li><li class="chapter-item expanded "><a href="golang/一致性hash.html"><strong aria-hidden="true">2.5.</strong> 一致性 hash</a></li><li class="chapter-item expanded "><a href="golang/grpc.html"><strong aria-hidden="true">2.6.</strong> grpc</a></li><li class="chapter-item expanded "><a href="golang/jwt.html"><strong aria-hidden="true">2.7.</strong> jwt</a></li><li class="chapter-item expanded "><a href="golang/uuid.html"><strong aria-hidden="true">2.8.</strong> uuid</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 微服务</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 操作系统</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 生活日常</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Title of Part</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">笔记记录</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>https://xiaolincoding.com/mysql/index/index_interview.html</p>
<h1 id="索引的分类"><a class="header" href="#索引的分类">索引的分类</a></h1>
<img src="mysql/./索引.assets/索引提纲.png" width = "700" height = "500" alt="索引" align=center />
<ul>
<li>按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 </li>
<li>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）</li>
<li>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</li>
<li>按「字段个数」分类：单列索引、联合索引。</li>
</ul>
<h3 id="不同数据结构实现的索引的差异"><a class="header" href="#不同数据结构实现的索引的差异">不同数据结构实现的索引的差异</a></h3>
<h4 id="btree"><a class="header" href="#btree">B+Tree</a></h4>
<ul>
<li>聚簇索引的叶子节点保存数据行的所有数据，并且相邻的叶子节点有（单向）指针指向下一个节点</li>
<li>只在叶子节点存储数据，段页区，每次取一页 16k，mei</li>
</ul>
<h4 id="hash"><a class="header" href="#hash">Hash</a></h4>
<ul>
<li>hash 索引只包含 hash 值和行指针</li>
<li>hash 索引不是按照值顺序存储，无法进行排序</li>
<li>hash索引使用索引列的全部内容计算 hash 值，因此不支持部分索引列匹配查找</li>
<li>hash 索引数据非常快，除非有hash 冲突较多，出现 hash 冲突时，要遍历链表中所有的行指针，逐行检查知道符合</li>
<li>hash 冲突较多时，删除也需要遍历 hash 链表中的每一行，冲突越多代价越大</li>
<li>hash 只支撑等值比较查询 =、in()、&lt;&gt;，不支持范围查询</li>
</ul>
<h4 id="full-text"><a class="header" href="#full-text">Full-text</a></h4>
<h3 id="慢查询分析与解决"><a class="header" href="#慢查询分析与解决">慢查询分析与解决</a></h3>
<div style="break-before: page; page-break-before: always;"></div><p>https://blog.codinglabs.org/articles/theory-of-mysql-index.html</p>
<pre><code class="language-sql">show variables like 'profiling'
set profiling=ON;
SHOW PROFILES;
SHOW PROFILE all limit 10;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库的时间字段有以下几种保存类型"><a class="header" href="#数据库的时间字段有以下几种保存类型">数据库的时间字段有以下几种保存类型</a></h1>
<h2 id="datetime"><a class="header" href="#datetime">DATETIME</a></h2>
<ul>
<li>存储的时间是服务器当前的时区的时间，查看mysql，存的是什么时间，查的就是什么时间 使用的时区 <code>show VARIABLES like '%time_zone%'</code></li>
<li>datetime的存储范围是1000-01-01到9999-12-31</li>
</ul>
<h2 id="timestamep"><a class="header" href="#timestamep">TIMESTAMEP</a></h2>
<ul>
<li>存储的时间是 UTC 时间，是将服务器当前时间转换为UTC(世界时间)来存储，查询的时候又会将 UTC 时间转换为当前时间。假如当前在东八区，那么存储的时间就是当前时间减去8小时的时间，当数据库的时区发生变化，查出来的时间也从 UTC 时间转换成当前时区的时间。</li>
<li>timestamp的存储范围是1970-01-01到2038-01-19，时间范围较少</li>
</ul>
<h2 id="int11"><a class="header" href="#int11">int(11)</a></h2>
<ul>
<li>存储的就是时间戳，是1970-01-01到至今的时间，时间戳有不同的精度，精确到 s 或者精确到 ms，这个需要根据业务需求来定，一般精确到 s 就够了，毕竟精确到 ms 会占用更多的存储空间，而且也不是很需要那么精确的时间。</li>
<li>int(11)换算成的成时间就是 UTC 时间，所以在使用的时候，需要将 UTC 时间转换成当前时区的时间，这个时候就需要用到 <code>CONVERT_TZ</code> 函数了。例如<code>CONVERT_TZ(FROM_UNIXTIME(op.created), '+00:00','+8:00')</code>,这里先用<code>FROM_UNIXTIME</code>函数把时间戳转换成 UTC 时间，然后再用<code>CONVERT_TZ</code>函数将 UTC 时间转换成当前时区的时间。</li>
</ul>
<h1 id="时间戳和时间转换"><a class="header" href="#时间戳和时间转换">时间戳和时间转换</a></h1>
<p>在这里 <code>DATE_FORMAT(CONVERT_TZ(FROM_UNIXTIME(op.created), '+00:00','+8:00'),'%Y-%m-%d')</code>就是把时间戳转换成时间，然后转换到对应的时区时间，再 format 处理成想要的时间格式。</p>
<h1 id="设置时区"><a class="header" href="#设置时区">设置时区</a></h1>
<pre><code>show VARIABLES like '%time_zone%'
SET time_zone = '+08:00';

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高可用"><a class="header" href="#高可用">高可用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go111module-变量"><a class="header" href="#go111module-变量">GO111MODULE 变量</a></h1>
<p>GO111MODULE = on 仍将强制使用 go module 机制</p>
<p>GO111MODULE = off 仍将强制使用 GOPATH 机制</p>
<p>GO111MODULE = auto 在 GOPATH 外部时，使用的是go module 机制，在 GOPATH 内部时使用的是 GOPATH 机制</p>
<h1 id="包管理的版本支持"><a class="header" href="#包管理的版本支持">包管理的版本支持</a></h1>
<ol>
<li>GOPATH 机制</li>
</ol>
<blockquote>
<p>在 1.5 版本之前，所有的依赖包都是存放在 GOPATH/src 下，没有多版本控制。</p>
</blockquote>
<ol start="2">
<li>vendor 机制</li>
</ol>
<blockquote>
<p>golang 1.5 版本推出了 vendor 机制。所谓 vendor 机制，就是每个项目的根目录下可以有一个 vendor 目录，里面存放了该项目的依赖的 package。go build 的时候会先去 vendor 目录查找依赖，如果没有找到会再去 GOPATH 目录下查找。</p>
</blockquote>
<ol start="3">
<li>go module</li>
</ol>
<blockquote>
<p>go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。</p>
</blockquote>
<h2 id="go-module"><a class="header" href="#go-module">go module</a></h2>
<pre><code>// 替换成本地依赖项
use replace github.com/maelvls/beers =&gt; ../beers 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>我想构建一个base 的公共库，给其他项目调,一开始想的很简单，直接在本地构建一个 base 库就搞定了就有了方案一</p>
<h2 id="方案一本地构建-base-库"><a class="header" href="#方案一本地构建-base-库">方案一：本地构建 base 库</a></h2>
<ul>
<li>
<p>在$GOPATH/src目录下创建项目 <code>mkdir -p $GOPATH/src/github.com/jiebiubiu/base</code></p>
</li>
<li>
<p><code>go mod init github.com/jiebiubiu/base</code></p>
</li>
<li>
<p>正常写库中的组件逻辑</p>
</li>
</ul>
<p>在另一个项目A 引用这个库，项目 A 的路径是<code>$GOPATH/src/github.com/jiebiubiu/A</code></p>
<p>go.mod</p>
<pre><code class="language-go">module github.com/jiebiubiu/A

go 1.20

require github.com/jiebiubiu/base v0.0.0 // 引入

replace github.com/jiebiubiu/base v0.0.0 =&gt; ../base   // 替换成 A 项目的相对路径去找base 库
</code></pre>
<p>导入使用使用 main.go</p>
<pre><code class="language-go">package main

import (
	&quot;github.com/jiebiubiu/base/logs&quot;
)

func main(){
	logs.InitLogger()
}

</code></pre>
<h2 id="方案二上传的-github-采用第三方库的方式导入"><a class="header" href="#方案二上传的-github-采用第三方库的方式导入">方案二：上传的 github 采用第三方库的方式导入</a></h2>
<ul>
<li>给 commit 打上一个标签 <code>git tag v1.0.0</code>然后<code>push</code>到仓库中<code>git push origin v1.0.0</code></li>
<li>项目引用<code>go get github.com/jiebiubiu/base@v1.0.0</code>然后就和正常库一样使用了</li>
</ul>
<h2 id="在这个过程遇到的坑"><a class="header" href="#在这个过程遇到的坑">在这个过程遇到的坑</a></h2>
<p>引入这个自定义的base第三方包遇到了一个这个问题：</p>
<p>go: github.com/jiebiubiu/base@v1.0.1: parsing go.mod: module declares its path as: github.com/Ho-J/base but was required as: github.com/jiebiubiu/base</p>
<p>为什么会遇到这个坑，是因为我这个 base 包一开始是 <code>go mod init github.com/Ho-J/base</code> 放在<code>$GOPATH/src/github.com/Ho-J/base</code>目录下，我想着把这个拆出来弄成第三方的包</p>
<p>然后在之前已经引入过的情况下出现这个问题</p>
<p>如何处理：</p>
<ul>
<li>base 项目 删除 go.mod go.sum 文件，执行<code>go clean -modcache</code>重新 <code>go mod init github.com/jiebiubiu/base</code> 重新 <code>go mod tidy</code></li>
<li>base 项目打上一个新的 tag <code>git tag v1.0.1</code> <code>git push origin v1.0.1</code></li>
<li>A 项目重新 <code>go get github.com/jiebiubiu/base@v1.0.1</code> 就完成了</li>
</ul>
<h2 id="方案三构建私有库"><a class="header" href="#方案三构建私有库">方案三：构建私有库</a></h2>
<p>还没遇到这个需求先放一放</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据的类型"><a class="header" href="#数据的类型">数据的类型</a></h1>
<h2 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h2>
<ul>
<li>整型，包括int，uint，int8，uint8，int16，uint16，int32，uint32，- int64，uint64，byte，rune，uintptr等</li>
<li>浮点型，包括float32，float64</li>
<li>复数类型，包括complex64，complex128</li>
<li>字符串类型，string</li>
<li>布尔型，bool</li>
</ul>
<h3 id="复合类型"><a class="header" href="#复合类型">复合类型</a></h3>
<ul>
<li>数组</li>
<li>struct结构体</li>
</ul>
<h3 id="引用类型"><a class="header" href="#引用类型">引用类型</a></h3>
<ul>
<li>slice</li>
<li>map</li>
<li>channel</li>
<li>pointer or 引用类型</li>
</ul>
<h3 id="接口类型"><a class="header" href="#接口类型">接口类型</a></h3>
<p>interface  io.Reader, io.Writer,error等</p>
<p>基本类型比较：两个变量类型必须一样才能比较</p>
<ul>
<li>类型完全不一样的，不能比较</li>
<li>类型再定义关系，不能比较，可以强转比较</li>
<li>类型别名关系，可以比较</li>
</ul>
<pre><code class="language-golang">    fmt.Println(&quot;2&quot; == 2) //invalid operation: &quot;2&quot; == 2 (mismatched types string and int)

    type A int
    var a int = 1
    var b A = 1
    fmt.Println(a == b) //invalid operation: a == b (mismatched types int and A)
    fmt.Println(a == int(b)) //true

    type C = int
    var c C = 1
    fmt.Println(a == c) //true
</code></pre>
<h1 id="复合类型的变量比较"><a class="header" href="#复合类型的变量比较">复合类型的变量比较</a></h1>
<ul>
<li>数组的元素类型和长度必须一致</li>
<li>结构体相同类型的结构体才能比较，匿名结构体的中包含的字段要一致，顺序也要一致，不能包含 map，有 map 就无法比较</li>
</ul>
<h1 id="引用类型比较"><a class="header" href="#引用类型比较">引用类型比较</a></h1>
<ul>
<li>slice类型不可比较，只能与零值nil做比较。</li>
<li>map类型和slice一样，不能比较，只能与nil做比较。</li>
<li>普通的变量引用类型&amp;val和channel，同一个引用就是同一个指针，相同就是一样的</li>
</ul>
<h1 id="interface类型变量的比较"><a class="header" href="#interface类型变量的比较">interface{}类型变量的比较</a></h1>
<p>接口类型的变量，包含该<strong>接口变量存储的值</strong>和<strong>值的类型</strong>两部分组成，分别称为接口的动态类型和动态值。只有动态类型和动态值都相同时，两个接口变量才相同。</p>
<pre><code class="language-golang">type Person interface {
    getName() string
}

type Student struct {
    Name string
}

type Teacher struct {
    Name string
}

func (s Student) getName() string {
    return s.Name
}

func (t Teacher) getName() string {
    return t.Name
}

func main() {

    s1 := Student{&quot;minping&quot;}
    s2 := Student{&quot;minping&quot;}
    t := Teacher{&quot;minping&quot;}

    fmt.Println(Person(s1) == Person(s2)) //true
	fmt.Println(Person(s1) == Person(t))  //false,类型不同
}
</code></pre>
<h1 id="函数类型比较"><a class="header" href="#函数类型比较">函数类型比较</a></h1>
<p>函数无法比较</p>
<h1 id="slice和map的特殊比较"><a class="header" href="#slice和map的特殊比较">slice和map的特殊比较</a></h1>
<ul>
<li>使用反射</li>
</ul>
<pre><code class="language-golang">m1 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2}
m2 := map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 2}
// fmt.Println(m1 == m2) // map can only be compared to nil
fmt.Println(reflect.DeepEqual(m1, m2)) // true
m2 = map[string]int{&quot;foo&quot;: 1, &quot;bar&quot;: 3}
fmt.Println(reflect.DeepEqual(m1, m2)) // false
m3 := map[string]interface{}{&quot;foo&quot;: [2]int{1,2}}
m4 := map[string]interface{}{&quot;foo&quot;: [2]int{1,2}}
fmt.Println(reflect.DeepEqual(m3, m4)) // true
var m5 map[float64]string
fmt.Println(reflect.DeepEqual(m5, nil)) // false
fmt.Println(m5 == nil) // true

s := []string{&quot;foo&quot;}
fmt.Println(reflect.DeepEqual(s, []string{&quot;foo&quot;})) // true
fmt.Println(reflect.DeepEqual(s, []string{&quot;bar&quot;})) // false
s = nil
fmt.Println(reflect.DeepEqual(s, []string{})) // false
s = []string{}
fmt.Println(reflect.DeepEqual(s, []string{})) // true
</code></pre>
<ul>
<li>[]byte类型的变量，使用工具包byte提供的函数就可以做比较</li>
</ul>
<pre><code class="language-golang">s1 := []byte{'f', 'o', 'o'}
s2 := []byte{'f', 'o', 'o'}
fmt.Println(bytes.Equal(s1, s2)) // true
s2 = []byte{'b', 'a', 'r'}
fmt.Println(bytes.Equal(s1, s2)) // false
s2 = []byte{'f', 'O', 'O'}
fmt.Println(bytes.EqualFold(s1, s2)) // true
s1 = []byte(&quot;źdźbło&quot;)
s2 = []byte(&quot;źdŹbŁO&quot;)
fmt.Println(bytes.EqualFold(s1, s2)) // true
s1 = []byte{}
s2 = nil
fmt.Println(bytes.Equal(s1, s2)) // true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>GOOS : 目标平台
mac 对应 darwin
linux 对应 linux
windows 对应 windows</p>
<p>GOARCH ：目标平台的体系架构【386，amd64,arm】, 目前市面上的个人电脑一般都是amd64架构的
386 也称 x86 对应 32位操作系统
amd64 也称 x64 对应 64位操作系统
arm 这种架构一般用于嵌入式开发。 比如 Android ， IOS ， Win mobile , TIZEN 等</p>
<p>CGO_ENABLED : CGO 表示golang中的工具，CGO_ENABLED 表示CGO禁用，交叉编译中不能使用CGO的</p>
<p>GOOS 目标平台</p>
<p>GOARCH 编译平台</p>
<pre><code># linux 下去执行
CGO_ENABLED=0  GOOS=linux  GOARCH=amd64  go build main.go
CGO_ENABLED=0 GOOS=windows  GOARCH=amd64  go  build  main.go
CGO_ENABLED=0 GOOS=darwin  GOARCH=amd64  go build main.go
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一致性-hash"><a class="header" href="#一致性-hash">一致性 hash</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="protobuf-grpc-安装"><a class="header" href="#protobuf-grpc-安装">protobuf grpc 安装</a></h2>
<pre><code>https://github.com/grpc/grpc-go
https://grpc.io/docs/languages/go/quickstart/

go get -u google.golang.org/grpc

go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
</code></pre>
<h2 id="protobuf-语法"><a class="header" href="#protobuf-语法">protobuf 语法</a></h2>
<p>https://protobuf.dev/programming-guides/proto3/</p>
<pre><code class="language-protobuf">
syntax = &quot;proto3&quot;;

option go_package = &quot;./;pb&quot;;


package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  rpc Search (SearchRequest) returns (SearchResponse);
}

message SearchRequest {
  string key = 1;
}

message SearchResponse{
  string value = 1;
}

// this is a comment
message Student {
  string name = 1;
  bool male = 2;
  repeated int32 scores = 3;
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre>
<h2 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h2>
<p><code> service-collection git:(main) ✗ protoc --go-grpc_out=./proto/pb --go_out=./proto/pb --proto_path=.  proto/*.proto</code></p>
<h4 id="option"><a class="header" href="#option">option</a></h4>
<p><code>option go_package = &quot;{out_path};out_go_package&quot;;</code></p>
<p>前一个参数用于指定生成文件的位置，后一个参数指定生成的 .go 文件的 package 。</p>
<p>一般使用这个配置<code>option go_package = &quot;./;pb&quot;;</code>，生成的就是和.proto 同层文家下，这样的文件package 是 pd  notice_task.pb.go</p>
<p>还有另外一种指定方式，命令行生成的时候 也使用<code>--go_opt=paths=source_relative</code>直接指定 protoc 中 指定的是绝对路径，这样就不会去管 protobuf 文件中指定的路径。</p>
<p><strong>–proto_path=.</strong></p>
<p>指定在当前目录( grpc-go-example)寻找 import 的文件（默认值也是当前目录）</p>
<p>然后 protobuf 文件中的 import 路径如下,其他路径都是以这个路径作为相对路径去寻址</p>
<p><strong>–go_out=./proto/pb</strong></p>
<p>指定将生成文件放在指定目录( ./proto)，同时因为 proto 文件中也指定了目录为<code>option go_package = &quot;./;pb&quot;;</code>,具体如下：</p>
<p>所以最终生成目录为<code>--go_out+go_package= /proto/pb</code></p>
<p><strong>proto/*.proto</strong> 要编译的文件</p>
<h2 id="import-注意事项"><a class="header" href="#import-注意事项">import 注意事项</a></h2>
<p><code>import &quot;proto/common.proto&quot;;</code> 这里的路径是相对路径，这个相对路径是相对于生成命令 <code>--proto_path</code> 这里指定的路径来说的</p>
<p>使用：</p>
<p>common.proto</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

option go_package = &quot;./;pb&quot;;

package pb;


message PingReq {
    string name = 1;
}

message PingResponse{
    string message = 1;
}
</code></pre>
<p>notice_task.proto</p>
<pre><code class="language-protobuf">
syntax = &quot;proto3&quot;;
option go_package = &quot;./;pb&quot;;
package pb;


import &quot;proto/common.proto&quot;;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc Ping(pb.PingReq) returns (pb.PingResponse);
}
</code></pre>
<h2 id="生成-go-文件"><a class="header" href="#生成-go-文件">生成 go 文件</a></h2>
<p>小疑问：https://zhuanlan.zhihu.com/p/441638893</p>
<pre><code>protoc --go-grpc_out=. --go_out=.  *.proto

protoc --go-grpc_out=./proto --go_out=./proto --proto_path=.  proto/*.proto 
</code></pre>
<p>proto 文件引用的问题 https://mileslin.github.io/2020/04/Golang/Import-%E5%85%B6%E4%BB%96-proto/</p>
<p>https://www.lixueduan.com/posts/protobuf/01-import/</p>
<div style="break-before: page; page-break-before: always;"></div><img src="golang/./assets/V4Usi.png" alt="img" style="zoom: 50%;" />
<h2 id="头部"><a class="header" href="#头部">头部</a></h2>
<p><code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p>
<pre><code class="language-javascript">{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<h2 id="payload"><a class="header" href="#payload">Payload</a></h2>
<p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<h2 id="签名字段"><a class="header" href="#签名字段">签名字段</a></h2>
<p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<h2 id="jwt-问题"><a class="header" href="#jwt-问题">jwt 问题</a></h2>
<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>
<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>
<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>
<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>
<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<h2 id="token-泄漏的问题解决"><a class="header" href="#token-泄漏的问题解决">token 泄漏的问题解决</a></h2>
<ol>
<li>
<p>ip绑定⽅式
⽣成token的时候，加密的payload加⼊当前⽤户ip。拦截器解密后，获取payload的ip和当前访问ip判断是否同个，如果不是则提示从新登录
优点：服务端⽆需存储相关内容，性能⾼，假如⽤户⼴州登录，泄露了token给四川的⿊客，依旧⽤不了
缺点：如果⽤户⽤使⽤过程中ip变动频繁，则操作会经常提
示重新登录，体验不友好</p>
</li>
<li>
<p>时间设置的短一些</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>https://z.wiki/tech/uuid.html</p>
<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，</p>
<p>如：550e8400-e29b-41d4-a716-446655440000。</p>
<p><code>UUID</code>包含<code>32</code>个<code>16</code>进制数字，分为<code>5</code>段，<code>5</code>段长度分别为<code>8</code>、<code>4</code>、<code>4</code>、<code>4</code>、<code>12</code>，中间使用连字符连接。</p>
<p>例如：<code>xxxxxxxx-xxxx-Mxxx-xxxx-xxxxxxxxxxxx</code></p>
<p>其中<code>M</code>表示 <code>UUID</code>的版本,从 <a href="https://devtool.tech/uuid">uuid生成 (opens new window)</a>可以看出，<code>M</code>位置的值和版本是一致的。</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>长度 （字节）</th><th>长度（16进制数字码长）</th><th>说明</th></tr></thead><tbody>
<tr><td>time_low</td><td>4</td><td>8</td><td>整数：低位 32 bits 时间</td></tr>
<tr><td>time_mid</td><td>2</td><td>4</td><td>整数：中间位 16 bits 时间</td></tr>
<tr><td>time_hi_and_version</td><td>2</td><td>4</td><td>最高有效位中的 4 bits“版本”，后面是高 12 bits 的时间</td></tr>
<tr><td>clock_seq_hi_and_res clock_seq_low</td><td>2</td><td>4</td><td>最高有效位为 1-3 bits“变体”，后跟13-15 bits 时钟序列</td></tr>
<tr><td>node</td><td>6</td><td>12</td><td>48 bits 节点 ID</td></tr>
</tbody></table>
</div>
<p>UUID由以下几部分的组合：
（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
（2）时钟序列。
（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>
<h2 id="uuid-version-1基于时间的uuid"><a class="header" href="#uuid-version-1基于时间的uuid">UUID Version 1：基于时间的UUID</a></h2>
<h2 id="uuid-version-2dce安全的uuid"><a class="header" href="#uuid-version-2dce安全的uuid">UUID Version 2：DCE安全的UUID</a></h2>
<p>DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</p>
<h2 id="uuid-version-3基于名字的uuidmd5"><a class="header" href="#uuid-version-3基于名字的uuidmd5">UUID Version 3：基于名字的UUID（MD5）</a></h2>
<p>基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</p>
<h2 id="uuid-version-4随机uuid"><a class="header" href="#uuid-version-4随机uuid">UUID Version 4：随机UUID</a></h2>
<h2 id="uuid-version-5基于名字的uuidsha1"><a class="header" href="#uuid-version-5基于名字的uuidsha1">UUID Version 5：基于名字的UUID（SHA1）</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
